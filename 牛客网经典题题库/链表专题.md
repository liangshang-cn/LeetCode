链表主要分为单链表、双向链表和循环链表三类，主要操作有遍历链表、插入节点和删除节点。




#### 203. 移除链表元素

删除链表中等于给定值  val 的所有节点。

```java
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode node = dummy;
        while (node.next != null) {
            if (node.next.val == val) {
                node.next = node.next.next;
            } else {
                node = node.next;
            }
        }
        return dummy.next;
    }
}
```

#### 83. 删除排序链表中的重复元素

给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。

```java
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if (head == null || head.next == null) {return head;}
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode node = head;
        while (node.next != null) {
            if (node.val == node.next.val) {
                node.next = node.next.next;
            } else {
                node = node.next;
            }
        }
        return dummy.next;
    }
}
```

#### 82.删除排序链表中的重复元素 II

给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中没有重复出现 的数字。

```java
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if (head == null || head.next == null) {return head;}
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode node = dummy;
        while (node.next != null && node.next.next != null) {
            if (node.next.val == node.next.next.val) {
                int val = node.next.val;
                ListNode cur = node.next;
                while (cur != null && cur.val == val) {
                    cur = cur.next;
                }
                node.next = cur;
            } else {
                node = node.next;
            }
        }
        return dummy.next;
    }
}
```

#### 19. 删除链表的倒数第N个节点

给定一个链表，删除链表的倒数第 *n* 个节点，并且返回链表的头结点。

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        int len = 0;
        ListNode t = head;
        while (t != null) {
            len++;
            t = t.next;
        }
        int pos = len - n + 1;
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode node = dummy;
        for (int i = 1; i < pos; ++i) {
            node = node.next;
        }
        node.next = node.next.next;
        return dummy.next;
    }
}
```

#### 147. 链表的插入排序

```java
class Solution {
    public ListNode insertionSortList(ListNode head) {
        if (head == null || head.next == null) {return head;}
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode prev = head;
        ListNode curr = head.next;
        while (curr != null) {
            ListNode currNext = curr.next;
            if (curr.val >= prev.val) {
                curr = curr.next;
                prev = prev.next;
            } else {
                prev.next = curr.next;
                ListNode run = dummy;
                while (run.next.val < curr.val) {
                    run = run.next;
                }
                curr.next = run.next;
                run.next = curr;
                curr = currNext; // 这里细节很重要，cur的位置改变后，下一轮循环的位置应该是curNext而不是cur.next
            }
        }
        return dummy.next;
    }
}
```

#### 143. 重排链表

给定一个单链表 L：L0→L1→…→Ln-1→Ln ，
将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…

```java
class Solution {
    public void reorderList(ListNode head) {
        if (head == null || head.next == null || head.next.next == null) {return;}
        ListNode slow = head, fast = head;
        while (fast.next != null && fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        ListNode newHead = slow.next;
        slow.next = null;
        newHead = reverse(newHead);
        while (newHead != null) {
            ListNode temp = newHead.next;
            newHead.next = head.next;
            head.next = newHead;
            head = newHead.next;
            newHead = temp;
        }
       
    }
    private ListNode reverse (ListNode head) {
        ListNode prev = null;
        ListNode curr = head;
        ListNode temp = head;
        while (curr != null) {
            temp = curr.next;
            curr.next = prev;
            prev = curr;
            curr = temp;
        }
        return prev;
    }
}
```

#### 141. 判断链表中是否有环

```java
public class Solution {
    public boolean hasCycle(ListNode head) {
        ListNode ps = head;
        ListNode pf = head;
        while (pf != null && pf.next != null) {
            ps = ps.next;
            pf = pf.next.next;
            if (ps == pf)
            return true;
        }
        return false;
    }
}
```

#### 142. 链表中环的入口

思路：快慢指针在环中相遇后，新结点从head出发，和相遇处的指针同步走，相遇点即为环的入口

证明：可以把路程分为三段：从head到环入口为 x， 从环入口到快慢指针相遇点为 y，环中与y相补的剩余部分是 z，则快慢指针相遇时，慢指针的路程为 x + y， 快指针的路程为 x + y + n * (y + z) ，快指针的路程是慢指针的两倍，即 2 * (x + y) = x + y + n * (y + z) => x + y = n * (y + z) => x = (n - 1) * (y + z) + z，

也就是说 x = z + n * 环的周长

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        if (head == null || head.next == null || head.next.next == null) {
            return null;
        }
        ListNode slow = head;
        ListNode fast = head;
        while (fast.next != null && fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            if (fast == slow) {
                ListNode temp = head;
                while (fast != temp) {
                    fast = fast.next;
                    temp = temp.next;
                }
                return fast;
            }
        }
        return null;
    }
}
```

